<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>01</title>
  <!-- <link rel="stylesheet" href="lib/css/monokai-sublime.css"> -->
  <link rel="stylesheet" href="lib/css/default.min.css">
  <link rel="stylesheet" href="lib/css/vs2015.css">
  <link rel="stylesheet" href="lib/css/zTreeStyle/zTreeStyle.css">
  <link rel="stylesheet" href="lib/css/base.css">
  <link rel="stylesheet" href="lib/css/index.css">
</head>

<body>
  <div style='width:25%;'>
    <ul id="tree" class="ztree" style='width:100%'>

    </ul>
  </div>
  <div id='readme' style='width:70%;margin-left:20%;'>
    <article class='markdown-body'><h2 id="-">学习目标</h2>
<ul>
<li>掌握JS的基本语法</li>
<li>了解编程思维</li>
</ul>
<h2 id="js-">Js的历史</h2>
<blockquote>
<p>Nombas与ScriptEase</p>
</blockquote>
<p>大概在 1992 年，一家称作 Nombas 的公司开发了一种叫做 C 减减（C-minus-minus，简称 Cmm）的嵌入式脚本语言,并将这个脚本语言捆绑在一个可以嵌入到浏览的2的共享软件中，代表了第一个在万维网上使用的客户端语言。后来由于mm听起来比较消极，Nombas又将Cmm的名字修改为ScriptEase.虽然Nombas如今在互联网行业已经销声匿迹，但是它的理念却成为因特网的一块重要基石。</p>
<blockquote>
<p>Netscape与JavaScript</p>
</blockquote>
<p>当网上冲浪越来越流行时，对于开发客户端脚本的需求也逐渐增大。那时，大部分因特网用户还仅仅通过 28.8 kbit/s 的调制解调器连接到网络，即便这时网页已经不断地变得更大和更复杂。而更加加剧用户痛苦的是，仅仅为了简单的表单有效性验证，就要与服务器进行多次地往返交互。设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段。</p>
<p>为了解决这一问题，NetScape公司的 Brendan Eich 开始为即将在1995年发行的 Netscape Navigator 2.0浏览器开发一款名为LiveScript的脚本语言，最终NetScript与Sun公司合作完成了LiveScript,并且将这种语言命名为JavaScript.</p>
<blockquote>
<p>微软与JScript</p>
</blockquote>
<p>在JavaScript 1.1 版本发布时，微软公司也决定进军浏览器行业。微软公司在推出的IE 3.0上搭载了一个JavaScript的克隆版，并且命名为JScript.</p>
<blockquote>
<p>ECMAScript</p>
</blockquote>
<p>在微软进入后，有 3 种不同的 JavaScript 版本同时存在：Netscape Navigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase.和其他编译语言不同的是，JavaScript 并没有一个标准来统一其语法或特性，而这 3 种不同的版本恰恰突出了这个问题。</p>
<p>1997 年，JavaScript 1.1 作为一个草案提交给欧洲计算机制造商协会（ECMA）.ECMA指派由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的第 39 技术委员会(TC39) 锤炼出了 ECMA-262，该标准定义了名为 ECMAScript 的全新脚本语言。</p>
<h2 id="javascript-">JavaScript是什么</h2>
<blockquote>
<p>JavaScript是一种运行在客户端（浏览器）的脚本语言</p>
</blockquote>
<p>客户端：<strong>客户端</strong>是相对于服务器而言的，在这里先简单为浏览器</p>
<p>浏览器就是一个客户端软件，浏览器从服务器上将资源（html,css,js,图片等）请求下来 并且在本地利用浏览器去解析这些资源</p>
<p>服务器本质上也是一台电脑。用来接收客户端发过来的请求，并处理请求。同时存储数据 读取数据等操作</p>
<p>脚本语言：不需要编译 读取一行  解析一行  一行报错 下一行不会继续执行</p>
<ul>
<li>脚本语言 Js、PHP  源代码 ——&gt; 预编译 ———&gt; 运行</li>
<li>编译语言 Java、C++、C、OC、  源代码 ——&gt; 编译后的字节码文件 ——&gt; 运行</li>
</ul>
<h2 id="js-">JS的作用</h2>
<p>1、网页特效
2、表单验证
3、服务端的JS (node.js)
4、命令行工具 (node.js)
5、app
6、游戏开发</p>
<p>总结：JS无所不能，我们学习的JS方向主要针对的是web页面</p>
<h2 id="js-">JS的组成</h2>
<ul>
<li>ECMAscript JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关</li>
<li>DOM（document object model 文档对象模型）一套操作页面元素的API</li>
<li>BOM（browser object model  浏览器对象模型）一套操作浏览器功能的API</li>
</ul>
<h2 id="js-">JS的初体验</h2>
<pre><code class="lang-html">1、书写环境 （这对标签可以写在网页的任何位置，一般习惯放在body结束标签的前面）
&lt;script&gt;
    alert(&#39;Hello world&#39;);
&lt;/script&gt;
</code></pre>
<p>2、独立的JS文件 通过script标签引入</p>
<pre><code class="lang-html">&lt;script src=&quot;路径&quot;&gt;&lt;/script&gt;
</code></pre>
<p><strong>注意点</strong>
引用外部js文件的script标签中不可以写JavaScript代码</p>
<h2 id="-">注释</h2>
<p>1、单行注释 //  用在代码上
2、多行注释 /<em> 多行注释 </em>/  用在说明文档上</p>
<h2 id="-">输出语法</h2>
<pre><code class="lang-js">// 调用弹出框功能
alert(&#39;Hello world&#39;);
// 调用对话框功能
prompt(&#39;Hello&#39;);
// 确认框
confirm(&#39;Are you sure?&#39;);
// 向页面输入对应的值
document.write(&#39;你好呀&#39;);
// 向控制台输出日志
console.log(&#39;我是出现在控制台 ，一般用于后期调试代码&#39;);
</code></pre>
<h2 id="-">变量</h2>
<blockquote>
<p>内存里面一块被命名的内存空间
可以理解为一个带有标识的容器，用来存储数据</p>
</blockquote>
<h2 id="-">变量的好处</h2>
<blockquote>
<p>更方便程序员使用内存
方便程序维护</p>
</blockquote>
<p>变量内存图 
<img src="../02-其他资料/变量内存图.png" alt=""></p>
<pre><code class="lang-js">// 声明变量并赋值
var a = 1;
// 先声明 在赋值
var b;
b = 1;
// 变量未声明 直接赋值 这种不推荐 不符合规范 并且会带来问题（作用域）
c = 1;
// 不声明 不赋值 会直接报错 特殊值不会（name，top）
console.log(d);
// 同时声明多个变量 并单独赋值
var a,b,c,d;
a = 1;
b = 2;
c = 3;
d = 4;
// 同时申明多个变量并赋同一个值
var a = b = c = d = 1;
</code></pre>
<h2 id="-">变量命名规则和规范</h2>
<ul>
<li>规则 不遵守会报错
  -由字母、数字、下划线、$符号组成，不能以数字开头
  -不能是关键字和保留字，例如：var for while
  -区分大小写</li>
<li>规范 尽量遵守
  -变量名必须有意义
  -遵守驼峰式命名法 首字母小写，后面单词首字母大写 例如：userName userPassword</li>
<li>课堂测试</li>
</ul>
<h2 id="-">数据类型</h2>
<blockquote>
<p>在程序设计中，数据类型被定义为数据的种类，也就是说一系列可能值以及基于那些值的基本操作。
好处：更加充分和高效的利用内存</p>
</blockquote>
<p>六大数据类型</p>
<ul>
<li>基本数据类型（简单数据类型）<ul>
<li>number 数值型</li>
<li>string 字符串</li>
<li>boolean 布尔型</li>
<li>undefined 未定义</li>
<li>null 空引用</li>
</ul>
</li>
<li>引用数据类型（复杂数据类型）<ul>
<li>object</li>
</ul>
</li>
</ul>
<h2 id="number-">number数据类型</h2>
<blockquote>
<p>所有的数字都是Number数据类型 
利用typeof运算符可以返回当前数据的数据类型</p>
</blockquote>
<p>特殊值：NaN not a number 不是一个数字</p>
<p><strong>注意</strong> 小数的计算可能产生丢失精度的问题
问题来源：小数的2进制存储转换会带来丢失精度的问题
解决方法：扩大成整数去运算</p>
<h2 id="string-">string数据类型</h2>
<blockquote>
<p>所有添加了引号的数据都是字符串数据类型 单双引号都可</p>
</blockquote>
<p>转义字符：
<img src="media/1498289626813.png" alt=""></p>
<h2 id="-">布尔数据类型</h2>
<blockquote>
<p>布尔类型只有两个值 true或者false 多用于条件的判断</p>
</blockquote>
<h2 id="undefined-null">undefined null</h2>
<blockquote>
<p>undefined 未定义 变量只声明没有赋值的时候浏览器默认会赋值一个undefined
null 表示一个空的对象  一般用于将一些对象清空</p>
</blockquote>
<h2 id="-">数据类型之间的相互转换</h2>
<ul>
<li>将数据转换成数值型<ul>
<li>parseInt() 把字符串转换成整数</li>
<li>parseFloat() 把字符串转换成浮点数 parseFloat会解析第一个. 遇到第二个 .     或者非数字结束 如果解析的内容里只有整数，解析成整数</li>
<li>Number
  Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN</li>
</ul>
</li>
<li>将数据转换成字符串<ul>
<li>toString() 将数据转换成字符串</li>
<li>String() 将数据转换成字符串 有些数据不能用toString 比如 undefined null</li>
<li>隐式转换 任何数据只需要跟字符串相加最终结果一定是字符串</li>
</ul>
</li>
<li>将数据转换成布尔类型<ul>
<li>boolean()</li>
<li>0，null，undefined，空字符串，false 会被转转换成false 不成立的表达式也会</li>
</ul>
</li>
</ul>
<h2 id="-">操作符（运算符）</h2>
<blockquote>
<p>用来操作数据的符号，一般用于运算</p>
</blockquote>
<ul>
<li><p>算术运算符 (+,-,*,/,%)</p>
<ul>
<li>加、减、乘、除、取模    </li>
<li>加号：数值相加 字符相连</li>
</ul>
</li>
<li><p>赋值运算符 (=)</p>
<ul>
<li>将等号右边的值赋予给左边</li>
</ul>
</li>
<li>自增自减运算符（一元运算符）<ul>
<li>a++ ++后置 先使用 后自增</li>
<li>++a ++前置 先自增 后使用</li>
<li>a-- --后置 先使用 后自减</li>
<li>--a --前置 后自减 先使用</li>
</ul>
</li>
<li>猜猜看：<pre><code class="lang-js">var a = 1; var b = ++a + ++a; console.log(b);    
var a = 1; var b = a++ + ++a; console.log(b);    
var a = 1; var b = a++ + a++; console.log(b);    
var a = 1; var b = ++a + a++; console.log(b);
console.log(5++); console.log(++5); 
</code></pre>
</li>
<li>自减
...</li>
</ul>
<h2 id="-">逻辑运算符</h2>
<blockquote>
<p>短路求值（Short-circuit evaluation，又称最小化求值），是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。例如，当AND的第一个运算数的值为false时，其结果必定为false；当OR的第一个运算数为true时，最后结果必定为true，在这种情况下，就不需要知道第二个运算数的具体值。在一些语言中（如Lisp），默认的逻辑运算符就是短路运算符，而在另一些语言中（如Java，Ada），短路和非短路的运算符都存在。对于一些逻辑运算，如XOR，短路求值是不可能的 。</p>
</blockquote>
<blockquote>
<p>逻辑运算符有三个：&amp;&amp;与 ||或 !取反</p>
</blockquote>
<ul>
<li>&amp;&amp; 前后必须都为真 则整个表达式则为真 一个为假整个表达式为假</li>
<li>|| 前后只要一个为真 则整个表达式就为真 两个都为假的话整个表达式才为假</li>
<li>!  取反 本来为真添加上!则为假  反之之前为假取反则为真</li>
</ul>
<p>逻辑运算求值策略：短路运算（短路求值）
逻辑与短路 只要前面是false  后面就不看了
逻辑或短路 只要前面是true 后面就不看了</p>
<h2 id="-">比较运算符</h2>
<blockquote>
<p>比较运算符  &gt;、 &lt;、 &gt;=、 &lt;=、 ==、 ===、 !=、 !==</p>
</blockquote>
<pre><code class="lang-js">// 比较运算符的结果都是布尔值
console.log(2 &gt; 1);
console.log(1 &gt; 2);

// &gt;= &lt;=  这个理解为大于或者等于  小于或者等于
console.log( 5 &gt;= 5 );
console.log( 5 &lt;= 5 );

// == 等于  只要内容相等即可
console.log(3 == 3);
console.log(3 == &#39;3&#39;);
console.log(0 == false);
// === 全等  全等不仅仅是内容相等 同时需要比较类型
console.log(3 === &#39;3&#39;);

// != 比较内容即可 !== 不仅比较内容还比较类型
console.log(3 !== &#39;3&#39;);

// 特殊情况
如果是数字和字符串的比较 则字符串数字会自动转换成数字去比较
如果是字符串和字符串比较 则会每一个字符的ASCII码去进行比较
涉及到NAN都是false （NaN）
如果是布尔值参与比较 布尔值会转换成数字0和1
</code></pre>
<h2 id="-">操作符优先级</h2>
<blockquote>
<p>不同的操作符之间的优先级有不同</p>
</blockquote>
<pre><code class="lang-text">优先级从高到低
1. ()  优先级最高
2. 一元运算符  ++   --   !
3. 算数运算符  先*  /  %   后 +   -
4. 关系运算符  &gt;   &gt;=   &lt;   &lt;=
5. 相等运算符   ==   !=    ===    !==
6. 逻辑运算符 先&amp;&amp;   后||
7. 赋值运算符
</code></pre>
<p>练习1：</p>
<pre><code class="lang-js">    var result =  1 + 2 * 8 / 4 ;    
    var result1 =  (1 + 2) * (8 / 4) ;   
    var result2 = !true + !false &gt;= 1;   
    var result3 = !true + (!false &gt;= 1);   
    var result4 = !(true + false)  
</code></pre>
<p>练习2：</p>
<pre><code class="lang-js">4 &gt;= 6 || &#39;人&#39; != &#39;阿凡达&#39; &amp;&amp; !(12 * 2 == 144) &amp;&amp; true
</code></pre>
<p>练习3：</p>
<pre><code class="lang-js">var num = 10;
5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === &#39;22&#39;
</code></pre>
<h2 id="-">表达式和语句</h2>
<blockquote>
<p>可以产生一个值的式子就是表达式  在现阶段可以理解为有运算符（不包括赋值运算符）的地方就是表达式</p>
</blockquote>
<p>如：a++  1+2+3;</p>
<blockquote>
<p>语句可以理解为一个行为  语句中可以包含表达式</p>
</blockquote>
<p>如：var a = 1;  var b = 2 + 4 + 6;</p>
<blockquote>
<p>语句的分类</p>
</blockquote>
<ul>
<li>顺序语句  自上而下一步一步执行 之前学习的所有都是顺序语句</li>
<li>分支语句  根据条件有选择的执行</li>
<li>循环语句  循环执行对应的语句</li>
</ul>
<h2 id="-">分支语句</h2>
<pre><code class="lang-js">if(条件){
    条件为真则执行大括号里面的代码
}

if(条件){
    条件为真则执行大括号里面的代码
}else{
    条件为假则执行这个括号里面的代码
}

if(条件1){
    条件1为真则执行这里的代码 并且不会继续执行下面的条件分支
}else if(条件2){
    如果条件1为假
    并且条件2为真则执行这里的代码 并且不会继续执行下面的条件分支
}else if(条件3){
    ...
}else{
    上述条件都不成立 则执行这里的代码
}
</code></pre>
<h2 id="-">调试断点</h2>
<blockquote>
<p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。</p>
</blockquote>
<p>调试步骤：</p>
<pre><code class="lang-html">  浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点
</code></pre>
<p>调试中的相关操作:</p>
<pre><code class="lang-js">    Watch:监视，通过watch可以监视变量的值的变化，非常的常用。
    F10:程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。
    F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。
</code></pre>
<p>tips: <strong>监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。</strong></p>
<p>苦口婆心一下：</p>
<ol>
<li>代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。</li>
<li>今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。</li>
</ol>
<h2 id="while-">while 语句</h2>
<pre><code class="lang-js">while(条件){
    条件为真时会不断执行这个代码 知道while的条件为假
}
</code></pre>
<p>所以while循环里面的条件的值是会发生变化的 如果没有变化 则就是一个死循环</p>
<h2 id="while-">while语句练习</h2>
<ul>
<li>打印1-100的和</li>
<li>打印100以内 7的倍数</li>
<li>打印100以内所有偶数</li>
<li>打印100以内所有偶数的和</li>
</ul>
<h2 id="do-while-">do while 循环</h2>
<blockquote>
<p>do while 循环最大的不同的就是while循环是先判断在循环  而do while是先do 一次 在开始循环 也就是说不管能不能循环 先do一次</p>
</blockquote>
<pre><code class="lang-js">do{
    // 循环语句
}while(true)
</code></pre>
<h2 id="do-while-">do while 循环练习</h2>
<ul>
<li>使用do-while循环：输出询问“我爱你，嫁给我吧？”，如果输入为“嫁”则打印”我们形影不离“，若输入为“不嫁”,则继续询问</li>
</ul>
<h2 id="for-">for 循环语句</h2>
<pre><code class="lang-js">
    for(语句1;语句2;语句4){
        语句3;
    }

    语句1：初始化语句 用来初始化变量
    语句2：循环的判断条件
    语句3：循环体
    语句4：循环体结束之后执行的代码
</code></pre>
<p>for循环语句练习</p>
<ul>
<li>打印1-100之间所有数</li>
<li>求1-100之间所有数的和</li>
<li>求1-100之间所有数的平均值</li>
<li>求1-100之间所有偶数的和</li>
<li>同时求1-100之间所有偶数和奇数的和</li>
</ul>
<p>for循环语句进阶练习</p>
<ul>
<li>打印出一个五行五列的心形</li>
<li>打印出一个五行递增列的心形 （一行一列，二行两列，三行三列，...）</li>
<li>打印99乘法表</li>
</ul>
<h2 id="break-continue">break和continue</h2>
<blockquote>
<p>break 跳出整个循环 
continue 跳出当前循环 继续下一次的循环 </p>
</blockquote>
<pre><code class="lang-html">求整数1～100的累加值，但要求碰到3的倍数则停止累加
求整数1～100的累加值，但要求跳过所有为3的倍数的数
</code></pre>
<h2 id="-">数组</h2>
<blockquote>
<p>所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。</p>
</blockquote>
<blockquote>
<p>数组是一个Array对象  属于复杂数据类型</p>
</blockquote>
<h2 id="-">创建数组</h2>
<blockquote>
<p>字面量形式</p>
</blockquote>
<pre><code class="lang-js">var arr = [&#39;内容1&#39;,&#39;内容2&#39;,&#39;内容3&#39;];
</code></pre>
<blockquote>
<p>构造函数形式</p>
</blockquote>
<pre><code class="lang-js">var arr = new Array(&#39;内容1&#39;,&#39;内容2&#39;,&#39;内容3&#39;);

细节注意: 使用构造函数形式array的小括号里面如果只写一个数值型的数据表示这个数组的长度 而不是内容
</code></pre>
<h2 id="-">数组的长度和下标</h2>
<p>获取数组的某一个元素：数组[下标]  下标从0开始
获取数组的长度 数组.length
数组的长度和下标的关系：arr.length - 1 = 最大的下标</p>
<p>数组的赋值</p>
<pre><code class="lang-js">//格式：数组名[下标] = 值;
//如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。
var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
arr[0] = &quot;yellow&quot;;//把red替换成了yellow
arr[3] = &quot;pink&quot;;//给数组新增加了一个pink的值
</code></pre>
<p>思考：如何给一个数组增加新的元素？</p>
<pre><code>1. 把1-100之间所有的数，放到数组中
2. 把1-100之间所有的奇数，放到数组中
3. 把1-100之间能被3整数的数字，存到数组中
</code></pre><h2 id="-">遍历数组</h2>
<blockquote>
<p>访问数组里面的每一个数据</p>
</blockquote>
<pre><code class="lang-js">    for(var i = 1; i &lt;= arr.length; i++){
        console.log(arr[i - 1]);
    }

    for(var i = 0; i &lt; arr.length; i++){
        console.log(arr[i]);
    }
</code></pre>
<h2 id="-">针对数组的应用</h2>
<ul>
<li>求一组数中的所有数的和的平均值</li>
<li>求一组数中的最大值和最小值 以及所在位置</li>
<li>将字符串数组用|或其他符号分割</li>
<li>要求将数组中的0项去掉，将不为0的的值存入到新的数组 生成新的数组</li>
<li>翻转数组</li>
</ul>
<h2 id="-">冒泡排序</h2>
<blockquote>
<p>冒泡排序是排序的一种</p>
</blockquote>
<blockquote>
<p>主体思路：两两之间相互比较，比较完毕之后最大的数就出来了，这是第一趟 然后重复第二次两两之间相互比较 比较完毕之后第二大的数就出来了
 一次类推 只需要比较数组的长度 - 1 次</p>
</blockquote>
<p>其他排序方式了解：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a></p>
<h2 id="-">函数</h2>
<blockquote>
<p>函数天生就是为了复用</p>
</blockquote>
<blockquote>
<p>声明函数和使用函数</p>
</blockquote>
<pre><code class="lang-js">// 声明函数
function 函数名 (){
    // 函数体
}

// 调用函数
函数名();
</code></pre>
<p>特点说明：</p>
<ul>
<li>函数默认不会执行 必须通过函数名()调用才会执行</li>
<li>函数的命名尽量遵守 动词或者动词+名词的方式 这样函数的作用一目了然</li>
</ul>
<pre><code class="lang-js">function greet(){
    console.log(Hi);
}

sayHi();
</code></pre>
<p>思考：</p>
<pre><code class="lang-js">1. 封装一个打招呼的函数
2. 封装一个函数，计算两个数的和
3. 封装一个函数，计算1-100之间所有数的和
</code></pre>
<h2 id="-">函数传参</h2>
<p>函数的参数极大的提高了函数的灵活性</p>
<blockquote>
<p>在声明函数的小括号里面写的数值我们称之为形式参数  形式参数的作用就是声明了两个变量 参数与参数之间用逗号隔开
在调用函数的小括号里面写的数值我们称之为实际参数  实际参数的作用就是给形式参数赋值，参数与参数之间用逗号隔开</p>
</blockquote>
<p>形参：声明变量
实参：给变量赋值</p>
<pre><code class="lang-javascript">//带参数的函数声明
function 函数名(形参1, 形参2, 形参...){
  //函数体
}

//带参数的函数调用
函数名(实参1, 实参2, 实参3);
</code></pre>
<p>思考：</p>
<pre><code class="lang-js">1. 计算1-n之间所有数的和
2. 计算m-n之间所有数的和
3. 班级有五个学生  计算着五个学生的总成绩
</code></pre>
<h2 id="-">函数的返回值</h2>
<blockquote>
<p>通俗的讲就是这个函数执行完毕之后的结果
在直观一点就是函数调用之后的值  默认是undefined</p>
</blockquote>
<pre><code class="lang-js">
    function doSomething(){
        // doing
        return result;
    }

    var jieguo = doSomething();
</code></pre>
<p>函数的返回值不是必要的，一般用于函数执行完毕之后产生一个结果 这个结果在其他地方需要使用的时候就需要返回值，如果当前函数没有返回值
浏览器会默认返回一个undefined</p>
<p>函数三要素：函数名，参数，返回值</p>
<p>思考1：</p>
<pre><code class="lang-javascript">1. 求任意半径的圆的面积
2. 求任意半径的圆的周长
3. 求任意2个数中的最大值
</code></pre>
<p>思考2：</p>
<pre><code class="lang-javascript">1. 求任意数组中的最大值
2. 求任意数组中的最小值
3. 翻转任意数组，返回一个新的数组
4. 对任意数组从小到大排序
</code></pre>
<h2 id="-">函数高级知识</h2>
<blockquote>
<p>函数内部是可以继续调用其他函数的</p>
</blockquote>
<pre><code class="lang-javascript">function fn1() {
    console.log(&quot;fn1开始...&quot;);
    fn2();
    console.log(&quot;fn1结束...&quot;);
}

function fn2 () {
    console.log(&quot;执行fn2的代码&quot;);
    console.log(&quot;执行fn2的代码&quot;);
    console.log(&quot;执行fn2的代码&quot;);
}

//在函数1中调用了函数2
fn1();
</code></pre>
<p>断点调试：</p>
<pre><code class="lang-javascript">1.    F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。
2.    F10：单步调试（跳过函数调用）
3.    F11：单步调试（进入函数调用）
4.    shift+F11：跳出函数调用
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 求阶乘
2. 求阶乘的和
3. 求任意3个数中的最大值
</code></pre>
<h2 id="-">参数的详解</h2>
<ol>
<li>两个相同的函数后面的会覆盖前面的函数</li>
<li>在Javascript中 实参的个数和形参的个数可以不一样<ul>
<li>如果实参过多 那么多余的实参会被忽略</li>
<li>如果形参过多 会自动填上undefined</li>
</ul>
</li>
</ol>
<h2 id="-">返回值的详解</h2>
<ol>
<li>函数的返回值就是fn();的结果  return多少 fn();就是多少</li>
<li>函数碰到return就不会在往下执行了  函数的结束用return  break是用在循环里面的</li>
<li>return;的写法相当于return undefined;</li>
</ol>
<p>思考:</p>
<pre><code class="lang-js"> 求数组中的最大值和最小值，并且返回
 难点：返回两个值
</code></pre>
<h2 id="-">全局变量和局部变量</h2>
<blockquote>
<p>全局变量：在script标签内部并且在函数外部声明的变量是全局变量
局部变量：在函数内部声明的变量就是局部变量
隐式全局变量：没有用var声明的变量是全局变量（隐式全局）不要使用</p>
</blockquote>
<p>全局作用域：在函数外部的区域就是全局作用域 在这里定义的变量都是全局变量
局部作用域：在函数内部的区域就是局部作用域 在这里定义的变量都是局部变量</p>
<h2 id="-">预解析</h2>
<blockquote>
<p>JS在真正执行之前，会预先解析所有的代码 会将变量声明和函数声明提前</p>
</blockquote>
<p>思考：</p>
<pre><code class="lang-js">// 重名getcool的问题
getCool();

// var 会提前声明
console.log(a);
  var a = 1;
  function a() {
    console.log(&#39;aaaa&#39;);
  }
console.log(a);
</code></pre>
<pre><code class="lang-javascript">//1.
var num = 10;
fn1();
function fn1() {
  console.log(num);//undefined
  var num = 20;
}

//2.
var a = 18;
fn2();
function fn2() {
    var b = 9;
    console.log(a);
    console.log(b);
}

//3.
fn3();
console.log(c);
console.log(b);
console.log(a);
function fn3() {
  a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}
</code></pre>
<h2 id="-">匿名函数</h2>
<blockquote>
<p>何为匿名函数  就是没有名字的函数</p>
</blockquote>
<pre><code class="lang-js">function(){

}
</code></pre>
<p>匿名函数因为没有名字 所以没有办法直接使用
1.通过将匿名函数赋值给一个变量 我们将这个称之为函数表达式
函数表达式值会预解析前面的var 后面的值不会被解析
2.函数自执行
匿名函数();</p>
<p>函数可以避免全局变量的污染</p>
<h2 id="-">对象</h2>
<p>何为对象：万物皆对象 客观世界中的具体的实体就是对象 如 一个人 一个气球  一辆汽车
思考：上述对象都是客观世界的，那JS这门语言中为什么要有对象呢 又如何用代码去描述一个对象呢</p>
<pre><code class="lang-js">
    // 描述一个对象之前，先描述对象所具备的属性

    // 创建一个空对象   跟数组的创建类似  只是将中括号改成了大括号 var web22 = [];
    var xmg = {
        name: &#39;小马哥&#39;,
        age: 18,
        height: 170,
        weight: 150,
        hobby: &#39;敲代码&#39;,
        star: &#39;处女座&#39;,
        gender: &#39;未知&#39;,
        sayHi: function(){
            console.log(&#39;Hi&#39;);
        },
        teach: function(){
            console.log(&#39;接下来我们开始讲解品优购&#39;)
        }
    };

    // 使用对象属性
    console.log(xmg.age);
    xmg.sayHi();

    // 新增对象属性
    xmg.face = &#39;big&#39;;
    // 修改对象属性
    xmg.age = 38;

    // 对象默认没有length属性
    console.log(xmg.length)
</code></pre>
<h2 id="-new-">通过new的形式来创建对象</h2>
<pre><code class="lang-js">    var obj = new Object({
        属性名1: 值1,
        属性名2: 值2,
        ...
    })

    // 使用对象的属性和修改对象的属性都是一样的
</code></pre>
<p>思考：如何将一个班级的所有学生对象都创建出来</p>
<h2 id="-">批量创建学生对象</h2>
<pre><code class="lang-js">// 上述都是重复去做一件事情 重复去做一件事情 我们就可以利用function封装 然后重复调用 传递对应的参数
  function creatStudent(name, age, height, hobby) {
    var obj = {
      name: name,
      age: age,
      height: height,
      hobby: hobby,
      sayHi: function () {
        console.log(&#39;Hello everyone&#39;);
      },
      study: function () {
        console.log(&#39;好好学习 天天向上&#39;);
      }
    }

    return obj;
  }

  var xmg = creatStudent(&#39;xmg&#39;, &#39;16&#39;, 180, &#39;嘿嘿&#39;);
  var wt = creatStudent(&#39;wt&#39;, &#39;14&#39;, 180, &#39;嘻嘻&#39;);
  var ff = creatStudent(&#39;ff&#39;, &#39;18&#39;, 110, &#39;呼呼&#39;);
</code></pre>
<h2 id="-new-">利用构造函数配合new关键字批量创建对象</h2>
<pre><code class="lang-js">//创建数组实例
var arr = new Array();
// 创建一个对象实例
var obj = new Object();
// 创建一个字符串实例
var str = new String();
// 创建一个number实例
var number = new Number();
// 创建一个布尔实例
var boolean = new Boolean();

// 需求： 创建一个学生对象
var stu = new Student();
</code></pre>
<h2 id="-new-">构造函数 和 new运算符</h2>
<pre><code class="lang-js">// 构造函数名字大写
function Student (name, age, hobby, gender){
    this.name = name;
    this.age = age;
    this.hobby = hobby;
    this.gender = gender;
}

var obj = new Student(&#39;小马哥&#39;, 18, &#39;开车&#39;, &#39;未知&#39;);
</code></pre>
<h3 id="new-">new 运算符</h3>
<ul>
<li>创建一个新的对象 类型从属于对应的构造函数</li>
<li>将this指向这个新对象</li>
<li>执行构造函数</li>
<li>返回这个新对象</li>
</ul>
<p>new运算符一般配合构造函数使用 这种方式创建对象更加简单。并且有原型关系（JS高级精讲）</p>
<h2 id="-">[]语法操作对象属性</h2>
<blockquote>
<p>对象[&quot;属性名&quot;]</p>
</blockquote>
<pre><code class="lang-js">    var obj = {
        name: &#39;feifei&#39;,
        age: 18,
        gender: &#39;男&#39;,
        i: 1
      };
      console.log(obj.age);

      var obj1 = {
        name: &#39;马哥&#39;,
        &#39;true-age&#39;: 20
      }
      console.log(obj1);

      // 关联数组的方式
      console.log(obj1[&quot;true-age&quot;]);

      // 点语法可以操作对象的属性  但是如果属性名中有-这些特殊字符的  通过.语法就操作不了
      // 但是我们可以利用关联数组的方式去操作
      // 对象[&#39;属性名&#39;]  或者 对象.属性名

      var i = &quot;name&quot;;
      console.log(obj.i); //  undefined 因为JS解析器会把I作为对象的属性  而当前对象并没有i这个属性  所以是udnefined
      console.log(obj[i]);// 关联数组的方式不加引号  会解析成变量 将变量里面存的值作为对象属性
      console.log(obj[&quot;i&quot;]); // 添加上了引号  直接解析成对象对应的属性
</code></pre>
<h2 id="-">遍历对象</h2>
<blockquote>
<p>通过for in语法</p>
</blockquote>
<pre><code class="lang-js">var obj = {
    name: &#39;feifei&#39;,
    age: 15,
    gender: &#39;male&#39;
  };

  /*for(var i = 0; i &lt; 3; i++){
    obj[0]
  };*/

  // for循环遍历对象的两个问题：
  // 1、对象的长度  也就是说循环多少次
  // 2、获取变量里面的具体属性

  for(var attr in obj){
    // console.log(&#39;1&#39;);
    // console.log(attr);
    console.log(obj[attr]);
  }
</code></pre>
<h2 id="-">引用数据类型和值数据类型</h2>
<blockquote>
<p>简单数据类型（值类型）
在存储时，变量中存储的是值本身，因此叫做值类型。
如：number string  boolean undefined null
复杂数据类型 （引用类型）
array object function
在存储时，变量中存储的仅仅是地址（引用），因此叫做引用数据类型</p>
</blockquote>
<p>思考题：</p>
<pre><code class="lang-js">//1.
var num1 = 10;
var num2 = num1;
num1 = 20;
console.log(num1);
console.log(num2);

//2.
var num = 50;

function f1(num) {
    num = 60;
    console.log(num);
}
f1(num);
console.log(num);

//3.
var num1 = 55;
var num2 = 66;
function f1(num, num1) {
  num = 100;
  num1 = 100;
  num2 = 100;
  console.log(num);
  console.log(num1);
  console.log(num2);
}

f1(num1, num2);
console.log(num1);
console.log(num2);
console.log(num);
</code></pre>
<p>思考题2：</p>
<pre><code class="lang-js">//1.
function Person(name, age) {
    this.name = name;
    this.age = age;
}
var p1 = new Person(&quot;zs&quot;, 18);
var p2 = p1;
p2.name = &quot;ls&quot;;
console.log(p1.name);
console.log(p2.name);

//2.
function Person(name, age) {
  this.name = name;
  this.age = age;
}
function f1(p) {
  p.name = &quot;ls&quot;;
  console.log(p.name);
}
var p1 = new Person(&quot;zs&quot;, 18);
console.log(p1.name);
f1(p1);
console.log(p1.name);

</code></pre>
<h2 id="-">内置对象</h2>
<h2 id="math-">Math对象</h2>
<pre><code>Math.PI  // π

// 求最大最小值
Math.max() // 求一组数中的最大数  如果里面的数据不能转换成数字 那么返回NaN
Math.min() // 求一组数中的最小值 如果里面的数据不能转化数字 那么返回NaN

// 取整 parseInt  Math.ceil || Math.floor || Math.round
Math.ceil(1.34); // 2  向上取整
Math.ceil(1.94); // 2  向上取整
Math.floor(1.34); // 1  向下取整
Math.floor(1.94); // 1  向下取整
Math.round(1.5) // 2 四舍五入  5向前进一位
Math.round(-1.5) // 1 四舍五入  5向前进一位

// 随机数 Math.random()
Math.random() // 返回一个0 - 1的随机数  包括0 但是不包括1
// 0-6的随机数   公式：0 - N的随机数 parseInt(Math.random() * (n + 1))
Math.random() * 7
//3-6的随机数
(Math.random() * 4) + 3  公式：M-N的随机数 parseInt((Math.random() * (N + 1)) + (M - N));

## Date对象
Date对象是一个创建和处理时间的对象
```js
// 创建当前时间 是你自己电脑的当前时间
var date = new Date(); // 当前时间的字符串
// 创建指定的时间
var date = new Date(&#39;2018-4-20 10:00:00&#39;);
</code></pre><p>JS获取时间是本地时间 所以一般不会用于做网页的倒计时 本地时间一般就是显示对应的时间</p>
<p>date对象的格式化 （不同的格式）</p>
<pre><code class="lang-js">console.log(date.toString()); // 和直接打印的一样 因为默认在输出的时候就转换成了字符串
console.log(date.toLocaleString());  //打印本地格式的时间 新版的chrome输出不一样
console.log(date.toDateString()); // 只打印日期
console.log(date.toTimeString()); // 只打印时时间
console.log(date.toLocaleTimeString()); // 打印本地时间格式

// 有兼容问题
</code></pre>
<h2 id="-date-">获取Date对象的指定部分</h2>
<pre><code class="lang-js">var date = new Date();
// 获取年份
date.getFullYear();
// 获取月份
date.getMonth();
// 获取日期
date.getDate();
// 获取小时
date.getHours();
// 获取分钟
date.getMinutes();
// 获取秒数
date.getSeconds();
// 组合成对应的字符串 2018-10-20 10:40:20

</code></pre>
<h2 id="-">时间戳</h2>
<blockquote>
<p>从1970年1月1号 00:00:00 到当前时间的毫秒数</p>
</blockquote>
<pre><code class="lang-js">//var date = new Date();
//console.log(+date);

var begin = new Date();
var sum = 0;
for(var i = 0; i &lt; 100000; i++){
    sum += i;
}
var end = new Date();
console.log(end - begin);
</code></pre>
<h2 id="-">内置对象之数组对象</h2>
<p>思考：将数组里面的数据用|分割成字符串</p>
<p>join方法是将数组里面的数据用特定的分隔符连接起来 返回一个新的字符串 不会对原数组产生影响
参数是 分隔符 不传则默认是,</p>
<pre><code class="lang-js">    var arr = [&#39;飞飞&#39;,&#39;马哥&#39;,&#39;海棠&#39;,&#39;香香&#39;,&#39;班长&#39;];
    //  var str = &#39;&#39;;
    //  for(var i = 0; i &lt; arr.length; i++){
    //    str += arr[i] + &#39;|&#39;;
    //  }
    //  console.log(str);

  //join 方法是将字符串按照特定的分隔符进行连接 返回连接好的字符串 不修改原来的数组
  var str = arr.join(&#39;|&#39;);
  console.log(str);
</code></pre>
<blockquote>
<p>增删操作</p>
<pre><code>push(); //向数组的最后一位追加新的一个或多个元素 并返回新的数组长度
pop(); // 截取数组的最后一位并返回这个截取的值
unshift(); //向数组的第一位追加新的一个或多个元素 并返回新的数组长度
shift();// 截取数组的第一一位并返回这个截取的值
</code></pre><p>思考题：</p>
<pre><code>var arr = [&#39;刘备&#39;];
// 添加数据之后变成 : [&quot;赵云&quot;,&quot;马超&quot;,&quot;刘备&quot;,&quot;关羽&quot;,&quot;张飞&quot;];
// 删除数据之后变成 : [&quot;关羽&quot;,&quot;张飞&quot;]
</code></pre><pre><code>思考题2：
var arr = [&quot;赵云&quot;,&quot;马超&quot;,&quot;刘备&quot;,&quot;关羽&quot;,&quot;张飞&quot;];
// 把数组的最后一位变成数组的第一位 [&quot;张飞&quot;,&quot;赵云&quot;,&quot;马超&quot;,&quot;刘备&quot;,&quot;关羽&quot;]
// 把数组的第一位变成数组的最后一位 [&quot;马超&quot;,&quot;刘备&quot;,&quot;关羽&quot;,&quot;张飞&quot;,&quot;赵云&quot;]
</code></pre></blockquote>
<h2 id="-">数组的翻转和排序</h2>
<blockquote>
<p>reverse()  翻转原数组</p>
</blockquote>
<pre><code class="lang-js">// array.reverse();  翻转原数组
var arr = [1,2,3,4,5,6];
arr.reverse();
console.log(arr); // [6,5,4,3,2,1]
</code></pre>
<blockquote>
<p>sort()  对数组进行排序  参数是function  不传的话默认以unicode码进行排序</p>
</blockquote>
<pre><code class="lang-js">var arr = [2, 11, 33, 5, 43, 7, 4, 3, 6];
  // 默认sort排序是按照unicode编码来排列的
  arr.sort();
  // a,b 这两个值代表两两比较的数 根据函数返回值来排序 如果返回值小于0 则交换a 和 b的位置
  arr.sort(function (a, b) {
    return a - b;
  });
  console.log(arr);
  arr.sort(function (a, b) {
    return b - a;
  });
  console.log(arr);
</code></pre>
<p>思考题：</p>
<pre><code class="lang-js">var arr = [&#39;eeeee&#39;,&#39;a&#39;,&#39;ccc&#39;,&#39;bb&#39;,&#39;dddd&#39;];  // =&gt; [&#39;a&#39;,&#39;bb&#39;,&#39;ccc&#39;,&#39;dddd&#39;,&#39;eeeee&#39;]
</code></pre>
<pre><code class="lang-js">var arr = [
    {name: &#39;zs&#39;,age: 18, score:90},
    {name: &#39;ls&#39;,age: 88, score:10},
    {name: &#39;ww&#39;,age: 9, score:0},
    {name: &#39;zl&#39;,age: 28, score:100},
    {name: &#39;tx&#39;,age: 33, score:88},
    {name: &#39;wb&#39;,age: 2, score:150}
]
// 按照年纪从小到大排序
// 按照分数从大到小排序
</code></pre>
<h2 id="-">数组的连接和裁切</h2>
<blockquote>
<p>concat()  合并多个数组</p>
</blockquote>
<p>参数：一个或者多个数组
返回值：合并好的新数组</p>
<pre><code class="lang-js">// 数组的合并
  var arr1 = [1, 2, 3, 4];
  var arr2 = [5, 6, 7, 8];
  //  concat 方法可以合并一个或多个数组 返回新的数组 不会对原数组造成影响
  var newArr = arr1.concat(arr2);
  console.log(arr1, arr2, newArr);
</code></pre>
<blockquote>
<p>slice 获取数组的某一部分</p>
</blockquote>
<p>参数：begin  开始下标 可选
参数2：end 结束下标 返回的值不包括end下标对应的值 可选
返回值：新数组 这个数组包含复制出来的值
注意：如果不传递 则直接拷贝（包括end的值）或者end不传 默认是从begin到end  包括end的值  不会对原数组造成影响</p>
<pre><code class="lang-js">// 返回数组某一部分 slice （复制数组到新数组）  参数是开始的下标和结束的下标（不包括结束的下标）如果不传递 这是0 - end
// 只传递一个n  就是n - end
  var arr = [&#39;马哥&#39;, &#39;飞飞&#39;, &#39;糖糖&#39;, &#39;香香&#39;];
  console.log(arr.slice(1, 3)); // 不包括end
  console.log(arr.slice()); // 如果end值不传递 会默认截取到最后包括最后一个
  console.log(arr.slice(1));// 如果end值不传递 会默认截取到最后包括最后一个
  console.log(arr);// 不修改原数组
</code></pre>
<blockquote>
<p>splice 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 (数组的剪切)</p>
</blockquote>
<p>参数1：begin number 截取的开始下标
参数2：number 截取的个数 可选 不传递则是begin - end
参数3：填充的值  可选
返回值：返回剪切出来的数组 会对原数组造成影响</p>
<pre><code class="lang-js">  // splice 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。
  // 参数：number 删除的起始下标
  // 参数2：number 删除的个数
  // 参数3：要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素
  // 返回值：删除的元素
  // 会改变原始数组
  var arr = [&#39;马哥&#39;, &#39;飞飞&#39;, &#39;糖糖&#39;, &#39;香香&#39;];

  var newArr = arr.splice(1, 2,&#39;嘻嘻&#39;,&#39;呵呵&#39;);
  console.log(newArr, arr);g
</code></pre>
<p>课堂小练习</p>
<pre><code class="lang-js">var arr = [4, 6, 7, 8, 3, 46, 8];
// 1. 从数组中截取一个新的数组[6,7,8,3],返回新的数组
// 2. 删除3,46
// 3. 添加100,200到7后面
</code></pre>
<h2 id="-">查找元素在数组中的位置</h2>
<blockquote>
<p>indexOf() 查找元素在数组中第一次出现的位置</p>
</blockquote>
<p>参数1：需要查找的值
参数2：从哪下标开始 默认是0
返回值：这个值在这个数组中对应的下标
注意：如果没有查找到  会返回-1 可以用来判断某个值是否在数组中</p>
<blockquote>
<p>lastIndexOf()  从数组的后面往前面查找</p>
</blockquote>
<p>数组的综合练习</p>
<pre><code class="lang-js">var arr = [&#39;c&#39;,&#39;a&#39;,&#39;z&#39;,&#39;a&#39;,&#39;x&#39;,&#39;a&#39;,&#39;a&#39;,&#39;z&#39;,&#39;c&#39;,&#39;x&#39;,&#39;a&#39;,&#39;x&#39;];
//1. 找到数组中一个a出现的位置
//2. 找到数组中最后一个a出现的位置
//3. 找到数组中每一个a出现的位置
//4. 数组去重，返回一个新数组
//5. 获取数组中每一个元素出现的次数 （难）
</code></pre>
<h2 id="-">字符串方法</h2>
<blockquote>
<p>字符串也可以看做是一个字符数组（伪数组）因此字符串也是有长度的 并且也可以遍历  很多方法和数组的方法一样
字符串方法不会修改原来的字符串</p>
</blockquote>
<ul>
<li>获取字符在字符串的位置</li>
</ul>
<pre><code class="lang-js">  indexOf(); // 获取某一个字符串第一次出现的位置  如果没有 返回-1
  lastIndexOf();// 从后面开始查找某一个字符串第一次出现的位置 如果没有返回-1
</code></pre>
<ul>
<li>去除字符串两边的空白</li>
</ul>
<pre><code class="lang-js">trim(); // 去掉字符串两边的空白
</code></pre>
<p>表单验证用到的很多</p>
<ul>
<li>字符串的拼接</li>
</ul>
<pre><code class="lang-js">// 实际工作中一般用+拼接即可
concat(); //字符串拼接
</code></pre>
<ul>
<li>字符串截取<pre><code class="lang-js">// 截取字符串
slice()  // 从start开始 end结束 不包括end
substring() // 从start开始 end结束 不包括end
substr() // 从start开始 截取length个字符
</code></pre>
</li>
<li>字符串的切割<pre><code class="lang-js">// 字符串切割
split() // 把一个字符串通过特点的符号切割成数组 参数：对应的符号
</code></pre>
</li>
<li>字符串替换<pre><code class="lang-js">replace(searchValue,newValue); // 替换字符串
</code></pre>
</li>
<li>练习<pre><code class="lang-js">//1. 截取字符串&quot;我爱中华人民共和国&quot;，中的&quot;中华&quot;
//2. &quot;abcoefoxyozzopp&quot;查找字符串中所有o出现的位置
//3. 把字符串中所有的o替换成!
//4. 把一个字符串中所有的空格全部去掉
//5. 统计一个字符串中每个字符出现的次数
</code></pre>
</li>
</ul>
</article>
  </div>
</body>
</html>
<script type="text/javascript" src="lib/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="lib/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="lib/js/ztree_toc.min.js"></script>
<script type="text/javascript" src="lib/js/toc_conf.js"></script>
<script src="lib/js/highlight.min.js"></script>
<script>
  $(document).ready(function () {
    // 代码高亮的js代码
    hljs.initHighlightingOnLoad();

    //生成侧边栏的代码
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts);
    $('#tree').ztree_toc(conf);
  });
</script>